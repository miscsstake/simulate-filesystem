# simulate-filesystem

设计文档：https://github.com/cooder-org/mos/blob/main/task1.md
## 问题一：MOS的实现分为了哪些部分？每一部分的职责是什么？每个部分之间的交接面是什么
- 磁盘层
- 文件层
- 进程管理层
- 应用层
### 磁盘层
磁盘层可以分为 `抽象API层`和 `具象实现API层`；
#### `抽象API层`:
> 职责是屏蔽不同具体磁盘的差异化，对外提供统一磁盘操作API。

磁盘操作包括磁盘的读取、写入 、格式化、关闭等操作；上层API不需要关注具体磁盘的运行原理，只需要使用 `抽象API`层提供的能力即可，而具体磁盘的操作交由 `具象磁盘API层`实现
#### `具象磁盘API层`：
> 职责提供访问物理磁盘的能力

磁盘可以有不同的类型，比如物理磁盘、逻辑磁盘、网络磁盘等；
不同的磁盘可以有不同的空间大小，每次读取的最小分区大小等等，针对差异比较大的磁盘可以由不同的`具象磁盘API`去管理；

**抽象磁盘API层通过具象磁盘API层间接去访问不同的磁盘，并对外提供统一的磁盘管理API能力。**
### 文件层
比如我创建一个文件a, a是一个文件类型而不是目录类型，a文件最多能存多少数据？a文件中有数据时数据的大小是多少？为了数据安全做备份时，备份的数量是多少？a文件应该存储在那种存储介质等等；这些文件元数据信息必然需要有一块数据来存储，并且这块存储空间能结构化每部分的含义：标识文件大小or文件类型or其他信息；这就引出了文件结构层。
### 文件结构层
文件结构也可以有多种，比如`FAT16`、`FAT16X`、`FAT32`等等，不同的文件结构决定了在磁盘空间内每部分数据标识是那种数据；那这些文件结构的差异不能对上层暴漏，所以就需要有一个抽象的文件系统层
### 抽象文件层 & 具象文件层 & 文件API层
提供文件的管理：比如文件创建、删除、读取，写入，格式化。

- 抽象文件层: `FileSystem`
- 具象文件层： `UnixFileSystem`
- 文件API层： `File`
#### 抽象文件层
> 抽象文件层职责：屏蔽不同文件结构层的差异， 对外提供统一的文件系统访问能力

提供了磁盘层交互的一种抽象方式，定义了基本的文件操作接口：比如文件创建、删除、读取，写入，格式化
#### 具象文件层
`UnixFileSystem` 是 `FileSystem`的一种实现，比如文件结构，不同的操作系统决定了需要有不同的具象文件层操作文件；
#### 文件API层
虽然抽象文件系统提供了文件的操作，但是对外使用时还不够方便，比如判断文件大小，文件类型：文件or目录or其他类型、目录下所有文件等操作
文件API层`File`即是对`抽象文件API`基础接口的组装，解构；又提供给了额外的特性，比如文件操作符的管理
而每个部分的交界面：

- File 和 FileSystem 之间的交界面是 FileSystem 提供的那些文件系统通用操作的接口。File 依赖于 FileSystem 提供的这些方法来进行文件的实际操作。
- FileSystem 和 UnixFileSystem 之间的交界面就是 FileSystem 设定的所有抽象方法。UnixFileSystem 继承自 FileSystem，并提供了这些抽象方法在Unix环境下的具体实现。

### 进程管理层
当不同的应用层比如shell，ssh, scp等想去访问文件系统时，举个小例子：怎么识别那么多的命令，以及命令上之间的关系，比如echo命令的输出 重定向到一个新文件，并且grep；
类似于为了约束或者统一提供文件系统层的操作，以及管理命令之间的关系；进程管理层主要是提供定义统一的进程信息，管理不同进程之间的交互。
比如：`cat /hello/a.txt | grep "aa"`时，进程管理层提供提供一些进程上下文信息：

- 比如`stdin`, `stdout`, `stderr`等信息，
- 再比如实现管道的思想管理 不同命令之间信息的传递；
- 提供进程生命周期的管理等
### 应用层
目前有三个

- `shell`层
- `ssh`层
- `scp`层

虽然应用层不同，但是应用层应该利用`进程管理层`统一的能力去操作文件系统

## 问题二：如果要支持多文件系统，你会如何设计？

- **抽象接口**：抽象文件层对外提供统一的能力，它跟不同文件系统是解耦的，新增文件系统不应该影响到抽象文件层的变动。
- **文件系统注册**（File System Registration）：操作系统需要提供一个机制，允许文件系统在运行时注册自己。当一个文件系统被注册时，它需要提供一个实现了抽象文件系统接口的对象。
- **文件系统挂载**（File System Mounting）：操作系统需要提供一个机制，允许用户或者系统管理员将一个文件系统挂载到目录树的某个位置。挂载操作需要指定文件系统类型和设备，操作系统会查找对应的文件系统实现，然后使用该实现创建一个文件系统实例，并将其挂载到指定位置。
- **文件系统驱动**: 每种文件系统都需要一个驱动程序来实现抽象文件系统接口。文件系统驱动负责管理文件系统的内部结构，如元数据、索引节点和数据块等。
- **统一的文件系统命名空间**（Unified File System Namespace）：操作系统需要提供一个统一的文件系统命名空间，允许用户通过路径名访问任何挂载的文件系统。当用户访问一个文件时，操作系统会根据路径名找到对应的文件系统，然后调用该文件系统的驱动程序来完成操作。

通过这种设计，我们可以在运行时添加或删除文件系统，也可以在不修改应用程序的情况下支持新的文件系统类型。
## 问题三：如果要支持多磁盘挂载，你会如何设计？

- **磁盘设备抽象**：首先，需要定义一个通用的磁盘设备抽象，这个抽象应该包含所有磁盘设备共有的操作，如读取扇区、写入扇区等。所有的磁盘设备都应该实现这个抽象。
- **磁盘设备注册机制**：操作系统应该提供一个磁盘设备注册机制，允许不同的磁盘设备在运行时注册自己。当一个磁盘设备被注册时，它应该提供一个实现了通用磁盘设备抽象的对象。
- **磁盘设备挂载机制**：操作系统应该提供一个磁盘设备挂载机制，允许用户选择一个磁盘设备并将其挂载到一个目录上。挂载后，通过这个目录访问的所有文件操作都应该被重定向到对应的磁盘设备上。
- **文件路径解析**：操作系统应该能够根据文件路径解析出对应的磁盘设备和在该磁盘设备中的路径。例如，如果有一个磁盘设备挂载在/mnt/mydisk目录上，那么访问/mnt/mydisk/dir/file.txt这个路径时，操作系统应该将其解析为在mydisk磁盘设备中的/dir/file.txt路径。
- **磁盘设备格式化工具**：对于每种磁盘设备，都应该提供一个格式化工具，用于在一个磁盘设备上创建一个新的文件系统。
- **错误处理**：不同的磁盘设备可能会有不同的错误和异常，操作系统应该提供一种机制，允许磁盘设备报告错误，并将这些错误传递给应用程序。

通过这种设计，可以很容易地添加对新磁盘设备的支持，只需要实现通用磁盘设备抽象，并提供一个格式化工具即可。同时，应用程序可以透明地访问不同的磁盘设备，无需关心磁盘设备的具体实现。
## 问题四：如果要将系统与应用进行分离，你会如何设计？系统与应用的交接面是什么？
### 如何设计：

- 将各种shell命令作为一个系统层的能力；对外提供一个 **对象的注入**，不同应用层可以注入不同的对象，单是这些对象需要有统一的约束：比如标准输入输出、当前路径、等待命令行的输入等信息；
- 输出完命令后，应该统一的解析命令，无论是`cat`、`echo`等内置的命令(这个内置其实也是一个外部命令)，还是自定义的外部命令(java、php、 bash等命令)；都可以通过去特定路径下查询命令是否存在，这个路径可以是多个；
- 命令之间得有个管道的能力，链接起来命令之间的输出、输入
### 系统和应用的交界面是什么？
不同应用层通过系统定义的统一注入对象，利用系统提供的统一的命令解析，命令管道连接能力实现对文件系统的操作。
## 问题五：现有的实现里，哪些功能属于应用层逻辑，可以抽离出来？如何抽离？
应用层逻辑

- `shell`各种命令`cat`、 `echo`、`grep`、`ls`等各种命令
- ssh
- scp
### 如何抽离
`ssh`和 `scp`的共同点在于都是通过一个客户端远程登录到操作系统服务端的，那么服务端就可以使用同一个端口；登录进来之后，基本也是执行shell的各种命令；

所以三者执行命令时，

1. 应该调用统一的进程管理层，约束三者调用进程管理层时，提供 基础类型相同的一些信息：比如标准输入，标准输出，当前文件路径等信息；
2. 输出命令时：
    1. 进程管理层统一解析命令，根据命令的数量匹配进程数量，并通过管道的思想是想命令之间上线文的传递；
    2. 根据输出的命令路径去查询命令，命令不存在则返回；存在则 解析命令参数；第一个命令的输出传递到第二个命令的输入，以此递推
3. 所有命令执行完，进程管理层可以统一做一些收尾的工作：比如关闭进程操作符；关闭进程标准输入输出等；异常处理等；

其实还可以做一些优化，比如 `cat a.txt | ls`时，其实`ls`不需要等待`cat a.txt`执行完毕; 虽然`shell`解析命令时，会为`cat`和 `ls`分别创建一个管道，然后将`cat a.txt`的标准输出重定向管道的写端，将`ls`的标准输入重定向到管道的读端，然后shell 会创建两个子进程。但是`ls`并不从标准输入读取数据，所有`cat a.txt`的输出会被忽略


## 示例代码：
### scp模式：
> 输出: 注意是out

1.1 文件内容
```sql
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
bw.write("hello world");
bw.newLine();
bw.flush();
```
1.2上传本地文件到远程系统文件
```sql
scp -P 20222 /xxx/a root@:127.0.0.1:/
```
运行：
```sql
a | grep 'sss'
a > xx.txt
```
> 输入: 注意是input

```sql
BufferedReader br = new BufferedReader(new InputStreamReader(input));
String line;
while((line = br.readLine()) != null) {
  out.write(line+"\n");
}
out.flush();
```
执行
```sql
echo ss | x
cat xx.txt | x
```

注意事项：本地的文件不要在/tmp目录;
因为目前scp的实现是基于将本地文件先copy到/tmp目录下，在读取文件流到 MOS系统的（由于时间原因，这期没有时间改了）
### ssh登录
```sql
ssh root@127.0.0.1 -P 20222
```
















































